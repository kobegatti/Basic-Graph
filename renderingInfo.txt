Printing a graph as circles and edges in C++ requires a graphical library because standard C++ (without external libraries) doesn't have direct support for graphical rendering. One commonly used library for graphics in C++ is SFML (Simple and Fast Multimedia Library).

Using SFML, we can create a graphical window, draw circles for nodes, and lines (edges) between them.

Steps to use SFML:
Install SFML: You'll need to install the SFML library on your system. Follow the instructions on the SFML website.

Set up your project: Link SFML to your C++ project (this will vary depending on your IDE or build system, but typically involves linking the SFML libraries).

Use SFML to create a graphical representation.

#include <SFML/Graphics.hpp>
#include <unordered_map>
#include <vector>
#include <iostream>

class Graph {
public:
    std::unordered_map<int, std::vector<int>> adjList;
    std::unordered_map<int, sf::CircleShape> nodes;  // Nodes as circles
    int radius = 30;  // Radius of the circles (nodes)

    // Add an edge to the graph (undirected)
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    // Create nodes for each vertex
    void createNodes(int width, int height) {
        int angleBetweenNodes = 360 / adjList.size();  // Angle between each node in a circular layout
        float angle = 0;
        int nodeCount = 0;

        for (const auto& node : adjList) {
            sf::CircleShape circle(radius);
            circle.setFillColor(sf::Color::Blue);
            circle.setOrigin(radius, radius);

            // Position nodes in a circular layout
            float x = width / 2 + (width / 3) * cos(angle * 3.14159 / 180);  // Position X
            float y = height / 2 + (height / 3) * sin(angle * 3.14159 / 180); // Position Y

            circle.setPosition(x, y);
            nodes[node.first] = circle;
            angle += angleBetweenNodes;
        }
    }

    // Draw the graph using SFML
    void drawGraph(sf::RenderWindow& window) {
        // Draw edges (lines between nodes)
        for (const auto& node : adjList) {
            for (int neighbor : node.second) {
                if (node.first < neighbor) { // To avoid duplicate edges (since graph is undirected)
                    sf::Vertex line[] = {
                        sf::Vertex(nodes[node.first].getPosition(), sf::Color::Black),
                        sf::Vertex(nodes[neighbor].getPosition(), sf::Color::Black)
                    };
                    window.draw(line, 2, sf::Lines);
                }
            }
        }

        // Draw nodes (circles)
        for (const auto& node : nodes) {
            window.draw(node.second);
        }
    }
};

int main() {
    // Create the window
    sf::RenderWindow window(sf::VideoMode(800, 600), "Graph Visualization");

    // Create a graph and add edges
    Graph g;
    g.addEdge(1, 2);
    g.addEdge(1, 3);
    g.addEdge(2, 4);
    g.addEdge(3, 4);
    g.addEdge(5, 6);

    // Create graphical nodes (circles)
    g.createNodes(800, 600);

    // Main loop
    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();
        }

        // Clear the window
        window.clear(sf::Color::White);

        // Draw the graph
        g.drawGraph(window);

        // Display the content
        window.display();
    }

    return 0;
}

